---
description: 
globs: 
alwaysApply: true
---

## 代码上下文管理规则

除了记忆管理外，你还应该自动管理代码上下文，捕获用户的编程活动。遵循以下规则：

### 1. 自动化代码文件关联
当发生以下情况时，自动关联相关代码文件到当前会话：
- 讨论特定代码文件时
- 提及文件路径或文件名时
- 讨论特定代码功能模块时
- 引用代码片段时
- 提出代码修改建议时

关联方式：
```javascript
mcp_context_keeper_associate_file({
  sessionId: "当前会话ID",
  filePath: "识别到的相关代码文件路径"
})
```

关联触发阈值：
- 高确定性：文件路径明确提及
- 中确定性：讨论具体模块且能确定文件
- 低确定性：上下文暗示相关文件


### 2. 编辑记录
当检测到代码编辑操作时，自动记录变更：
- 功能新增：添加新的代码功能
- 缺陷修复：修复已有代码缺陷
- 性能优化：提升代码执行效率
- 重构改进：改善代码结构而不改变功能
- 接口变更：更改API或接口定义
- 依赖更新：更新第三方库或组件

记录策略：
```javascript
mcp_context_keeper_record_edit({
  sessionId: "当前会话ID",
  filePath: "编辑的文件路径",
  diff: "代码差异内容",
  metadata: {
    "editType": "编辑类型",
    "reason": "编辑原因",
    "relatedIssue": "相关问题标识",
    "functionalArea": "功能区域",
    "complexity": "复杂度评估"
  }
})
```

自动添加标签：
- 当编辑涉及核心架构时添加 #架构变更
- 当编辑修复问题时添加 #问题修复
- 当编辑改进性能时添加 #性能优化
- 当编辑重构代码时添加 #代码重构


### 3. 编程上下文获取
在以下情景自动获取编程上下文：
- 讨论代码实现细节前
- 分析问题原因时
- 设计新功能时
- 评审代码时
- 讨论代码变更的影响时
- 其他解答编程问题前

获取方式：
```javascript
mcp_context_keeper_programming_context({
  sessionId: "当前会话ID",
  query: "针对当前讨论的编程主题" //可选参数
})
```

上下文情境化：
- 自动关联相关的技术决策
- 链接到相关的代码讨论
- 提取代码修改历史中的关键点


### 4. 编程知识深度存储
自动识别并存储关键编程知识：
- 架构设计原则
- 设计模式应用
- 优化技巧
- 问题解决方法
- API使用范例
- 关键工具链配置

存储方式：
```javascript
mcp_context_keeper_memorize_context({
  sessionId: "当前会话ID",
  content: "编程知识内容",
  priority: "优先级",
  metadata: {
    "knowledgeType": "知识类型",
    "language": "编程语言",
    "framework": "框架",
    "applicationArea": "应用领域",
    "codeReferences": ["相关代码引用"]
  }
})
```

关联结构化信息：
- 当存储设计模式知识时，关联模式类型和UML图
- 当存储API用法时，关联参数说明和示例代码
- 当存储优化技巧时，关联性能指标和测试数据

### 5. 智能编程上下文检索
增强检索能力以支持编程场景，检索触发条件：
- 开始处理新的编程任务
- 继续未完成的编码工作
- 查找参考或示例代码
- 理解尚不熟悉的代码区域
- 跟踪代码演变历史

检索策略：
```javascript
mcp_context_keeper_retrieve_context({
  sessionId: "当前会话ID",
  query: "编程相关查询",
  filters: {
    "contentType": ["code", "design", "discussion"],
    "timeframe": "relevant_period",
    "relevance": "high_to_medium"
  }
})
```

技术语境识别：
- 自动识别查询中的技术术语
- 关联技术堆栈相关信息
- 提取代码示例与最佳实践


### 6. 编程记忆优先级评估框架
编程记忆优先级评估标准：

P1（高优先级）：
- 核心架构决策和变更
- 影响多个模块的API设计
- 系统性能关键优化
- 重大安全漏洞修复
- 重要数据模型变更
- 构建系统关键配置
- 核心逻辑变更
- API接口变更

P2（中优先级）：
- 单模块功能实现
- 常规问题修复
- 代码重构和改进
- 第三方库集成
- 测试策略讨论
- 非核心性能优化

P3（低优先级）：
- 代码风格讨论
- 变量命名约定
- 简单功能调整
- 非关键文档更新
- 提高可读性的注释添加
- 辅助工具配置


### 7. 编程行为触发器
以下编程行为自动触发记忆管理：

代码编写触发器：
- 添加新类/函数/模块
- 修改核心逻辑
- 重构现有代码
- 添加关键注释
- 更改API定义

问题解决触发器：
- 定位并修复bug
- 解决性能瓶颈
- 处理兼容性问题
- 增强安全性
- 改进用户体验

设计讨论触发器：
- 设计新功能
- 讨论技术选型
- 评审架构变更
- 分析实现方案
- 讨论模块划分

触发动作：
- 高级别行为：自动记录长期记忆
- 中级别行为：记录短期记忆并提示是否转为长期记忆
- 低级别行为：仅记录短期记忆

### 8. 代码与讨论双向关联
建立代码与讨论的双向引用：

关联建立时机：
- 讨论代码问题时
- 实现设计方案时
- 解释代码决策时
- 审查代码变更时
- 探讨代码改进时

关联方式：
- 代码指向讨论：在代码注释中引用讨论ID
- 讨论指向代码：在讨论中关联代码文件和代码片段
- 变更指向决策：代码变更引用设计决策
- 决策指向需求：设计决策关联业务需求

### 9. 编程模式和反模式识别
自动识别代码中的模式和反模式：

识别目标：
- 设计模式的应用
- 常见编程反模式
- 安全风险模式
- 性能优化模式
- 可维护性模式

识别后行动：
- 对正面模式：记录为最佳实践
- 对负面模式：提出改进建议并记录
- 对中性模式：记录应用场景和取舍

分享机制：
- 跨会话共享识别到的模式
- 在相似问题出现时提供参考

### 10. 集成到工作流程的自动触发点
在开发工作流程中的自动触发点：

项目初始化阶段：
- 关联项目核心文件
- 存储项目架构概览
- 记录技术栈选择理由

功能开发阶段：
- 关联需求与设计文档
- 记录功能实现方案
- 跟踪代码变更与原因

代码审查阶段：
- 记录重要审查意见
- 关联相关编码规范
- 存储改进建议

问题修复阶段：
- 关联问题描述与根因
- 记录修复策略
- 存储验证方法

发布部署阶段：
- 记录部署注意事项
- 存储回滚策略
- 关联性能基准测试


### 11. 代码上下文管理触发场景
以下场景应自动触发代码上下文管理工具：
- 打开或查看新文件
- 编辑或修改文件内容
- 保存文件
- 切换编辑的文件
- 运行代码
- 讨论特定文件或代码片段
- 解答编程相关问题
以下关键词应触发代码上下文管理：
- "这段代码"
- "这个文件"
- "修改代码"
- "实现功能"
- "调试问题"
- "解决错误"
- "代码优化"
- "重构"

### 12. 智能过滤
为避免信息过载，应忽略以下内容：
- 临时文件和编译产物
- 二进制文件变更
- 过大的文件变更
- 短时间内的连续小变更（应合并处理）



## 执行规则
1. 自动捕获并维护代码编辑历史
2. 在解答编程问题时优先利用已捕获的代码上下文 