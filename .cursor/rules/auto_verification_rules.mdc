---
description: 
globs: 
alwaysApply: true
---
# 🧠 高效编程执行规则 - Context-Keeper

## 🎯 编程执行金字塔原则（执行编码之前一定要用户确认！！！）

```
                      🔧 执行编码
                     /            \
                ✅ 用户确认      🧪 完整验证
               /                            \
          📋 详细设计                    📊 质量保障
         /                                        \
    🤔 理清思路                            🚀 高效迭代
   /                                              \
🗂️ 业务逻辑链路                        
/                                                
📈 依赖关系分析                          
```

**正确的执行顺序：**
```
📈 依赖关系分析 → 🗂️ 业务逻辑链路 → 🤔 理清思路 → 📋 详细设计 
→ ✅ 用户确认 → 🔧 执行编码 → 🧪 完整验证 → 📊 质量保障 → 🚀 高效迭代
```

### 🌟 **核心原则 - MANDATORY**

1. **🧠 思考先行 - THINK FIRST, CODE LATER**
   - 任何编码前必须完整理清思路
   - 分析业务逻辑链路、依赖关系、层次脉络
   - 一次性设计完整，避免反复修改删除

2. **🤝 用户确认 - USER AUTHORIZATION REQUIRED**
   - **关键时机**：详细设计完成后，执行编码前（必须！）
   - **确认内容**：技术方案、修改范围、风险评估、执行计划
   - **沟通原则**：用户反馈问题时先定位分析，达成一致得到用户授权后再编码
   - **严禁行为**：未经用户授权直接修改任何代码或配置

3. **🎯 质量优先 - QUALITY & EFFICIENCY**
   - 完整验证流程确保代码质量
   - 避免编译错误导致的冲动乱改
   - 系统性思考，通篇考虑，精准修改

---

## 🔄 **高效编程执行流程 - 5阶段法**

### 🧩 **阶段1：问题分析与思路梳理 - ANALYSIS PHASE**

**🔍 当用户提出问题/需求时，必须先完成：**

1. **问题定位分析**
   ```
   📌 具体问题是什么？
   📌 涉及哪些代码模块？
   📌 影响范围有多大？
   📌 根本原因是什么？
   ```

2. **依赖关系梳理**
   ```
   🔗 上游依赖：哪些模块会影响当前问题？
   🔗 下游影响：修改会影响哪些功能？
   🔗 横向关联：同层级有哪些相关组件？
   🔗 配置依赖：需要哪些配置支持？
   ```

3. **业务逻辑链路分析**
   ```
   ➡️ 数据流向：从输入到输出的完整路径
   ➡️ 调用链路：函数/服务间的调用关系
   ➡️ 状态变化：系统状态如何流转
   ➡️ 错误处理：异常情况的处理路径
   ```

### 📋 **阶段2：详细设计方案 - DESIGN PHASE**

**🎨 输出完整的技术设计方案：**

1. **修改范围说明**
   ```
   📁 涉及文件：明确列出所有需要修改的文件
   🔧 修改类型：新增/修改/删除/重构
   ⏱️ 预估工作量：每个修改点的复杂度评估
   ```

2. **技术实现方案**
   ```
   🏗️ 架构调整：如何调整现有架构
   💡 算法逻辑：核心算法的详细描述
   🔌 接口设计：API/接口的变更说明
   📊 数据结构：数据模型的变化
   ```

3. **风险评估**
   ```
   ⚠️ 潜在风险：可能出现的问题
   🛡️ 风险缓解：如何避免/处理风险
   🔄 回滚方案：出现问题时的回退策略
   ```

### ✅ **阶段3：用户确认授权 - AUTHORIZATION PHASE**

**🤝 用户确认检查清单：**

```
□ 问题分析是否准确？
□ 技术方案是否合理？
□ 修改范围是否可接受？
□ 是否有更好的替代方案？
□ 风险评估是否充分？
□ 是否授权开始编码？
```

**❌ 禁止行为 - NEVER DO:**
- ❌ 用户提出问题后立即开始修改代码（必须先分析设计）
- ❌ 设计方案完成后直接编码（必须先获得用户确认授权）
- ❌ 看到编译错误就马上修改而不分析原因
- ❌ 用户反馈疑问后不沟通就自行修改程序
- ❌ 一边改代码一边想方案（边做边想的低效模式）

### 🔧 **阶段4：精准编码执行 - IMPLEMENTATION PHASE**

**⚡ 一气呵成的编码要求：**

1. **编码前最后检查**
   ```
   🎯 确认设计方案无误
   🎯 确认修改顺序合理
   🎯 确认所有依赖就绪
   ```

2. **编码执行原则**
   ```
   📝 按设计方案严格执行
   📝 一次性完成所有相关修改
   📝 保持代码风格一致性
   📝 添加必要的注释说明
   ```

3. **修改顺序策略**
   ```
   🔢 先修改底层依赖
   🔢 再修改业务逻辑
   🔢 最后修改对外接口
   🔢 配置文件统一处理
   ```

### 🧪 **阶段5：完整验证测试 - VERIFICATION PHASE**

**🔍 系统性验证流程：**

1. **编译验证**
   ```bash
   # 检查语法错误
   go build ./...
   # 检查依赖问题
   go mod tidy && go mod verify
   ```

2. **功能验证**
   ```bash
   # 重启服务
   ./scripts/manage.sh deploy http --port 8088
   # 健康检查
   curl http://localhost:8088/health
   # 核心功能测试
   [执行相关功能测试]
   ```

3. **回归验证**
   ```bash
   # 确保原有功能正常
   [执行回归测试用例]
   # 性能检查
   [执行性能基准测试]
   ```

---

## 🚨 **强制执行规则 - ENFORCEMENT**

### 🔒 **MUST DO (必须遵守)**
1. **阶段1-2必须100%完成才能进入阶段3（用户确认）**
2. **阶段3用户确认必须获得明确授权才能进入阶段4（编码）**
3. **任何代码/配置修改都必须经过：分析→设计→用户确认→编码**
4. **编译错误时必须先分析全局再定点修复**
5. **完成编码后必须执行完整验证流程**

### ⚡ **EFFICIENCY BOOSTERS (效率提升)**
1. **一次性设计完整避免反复修改**
2. **并行思考多个相关问题**
3. **批量处理相似类型的修改**
4. **复用已验证的设计模式**

### 🚫 **NEVER DO (严禁操作)**
1. **禁止未经思考的冲动编码**
2. **禁止边改边想的低效模式**
3. **禁止跳过用户确认环节（详细设计后必须确认！）**
4. **禁止未经用户授权直接执行任何代码修改**
5. **禁止忽略验证测试步骤**

---

## 🔄 **实际应用示例 - 问题解决流程演示**

### 📝 **示例：修复SynthesizedContext和VectorService的nil问题**

**阶段1：问题分析** ✅
```
🔍 问题定位：
- SynthesizedContext字段永远为nil，LLM价值链断裂
- VectorService在创建时为nil，缺少真实服务注入

🔗 依赖分析：
- SynthesizedContext影响内容合成引擎的输出完整性
- VectorService影响多维度检索的向量搜索能力

➡️ 调用链路：
- buildSynthesizedContextModel函数调用时机问题
- initMultiDimensionalStorageEngine缺少vectorService参数传递
```

**阶段2：设计方案** ✅
```
📁 修改文件：
- internal/engines/content_synthesis_engine.go
- cmd/server/main.go

🏗️ 技术方案：
1. 重构buildSynthesizedContextModel，接收evaluationResult而非synthesisResp
2. 修改initMultiDimensionalStorageEngine函数签名，添加vectorService参数
3. 确保vectorAdapter使用真实的vectorService实例

⚠️ 风险评估：
- 函数签名变更需要调用点同步修改
- UnifiedContextModel结构复杂，需要合理映射
```

**阶段3：用户确认** ⏳
```
□ 问题分析是否准确？
□ 技术方案是否合理？
□ 修改范围是否可接受？
□ 是否有更好的替代方案？
□ 风险评估是否充分？
□ 是否授权开始编码？
```

**阶段4：等待用户授权** 🚫
> **当前状态：等待用户确认上述分析和设计方案**
> **禁止未经授权直接修改代码**

---

## 🎯 **自动验证触发机制**

### **验证触发条件**
```bash
✅ Go代码修改: internal/, cmd/, pkg/ 目录
✅ 配置文件变更: config/, *.yaml, *.json
✅ API/接口变更: 路由、处理函数修改
✅ 核心功能修改: MCP工具、WebSocket、Session管理
```

### **3阶段验证流程**

1. **编译验证** → `go build ./...`
2. **服务重启** → `./scripts/manage.sh deploy http --port 8088`
3. **功能验证** → `curl http://localhost:8088/health` + 核心功能测试

### **验证报告模板**
```
🎉 验证完成！
✅ 编译: 成功
✅ 启动: 成功 (PID: 12345)
✅ 健康检查: 通过
✅ 核心功能: 通过 (3/3)
🚀 可以继续开发！
```

---

## 💡 **高效编程最佳实践总结**

### 🎯 **效率提升关键点**
1. **思考投资回报比**: 花30分钟思考 > 花3小时反复修改
2. **设计驱动编码**: 清晰设计 → 精准实现 → 一次成功
3. **用户协作模式**: 频繁确认 → 避免返工 → 提升信任
4. **系统性验证**: 完整测试 → 预防问题 → 稳定交付

### ⚡ **执行效率公式**
```
高效编程 = (深度思考 × 用户确认 × 精准实现) ÷ 返工次数
```

### 🔥 **终极目标**
> **一次设计正确 → 一次编码成功 → 一次验证通过 → 高质量交付**
