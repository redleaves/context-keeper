package services

import (
	"context"
	"fmt"
	"log"
	"math"
	"net/http"
	"os"
	"strings"
	"time"

	"github.com/anush008/fastembed-go"
)

// =============================================================================
// ğŸš€ ç­–ç•¥1: å¢å¼ºæœ¬åœ°ç­–ç•¥ï¼ˆå½“å‰ä½¿ç”¨çš„ä¿®å¤ç‰ˆJaccardï¼‰
// =============================================================================

type EnhancedLocalStrategy struct {
	name string
}

func NewEnhancedLocalStrategy() SimilarityStrategy {
	return &EnhancedLocalStrategy{
		name: "enhanced_local",
	}
}

func (s *EnhancedLocalStrategy) Name() string {
	return s.name
}

func (s *EnhancedLocalStrategy) IsAvailable(ctx context.Context) bool {
	return true // æœ¬åœ°ç®—æ³•æ€»æ˜¯å¯ç”¨
}

func (s *EnhancedLocalStrategy) GetCapabilities() StrategyCapabilities {
	return StrategyCapabilities{
		Name:         "Enhanced Local Similarity",
		Description:  "ä¿®å¤åçš„å¢å¼ºJaccardç®—æ³•ï¼Œæ”¯æŒå¤šç§ç›¸ä¼¼åº¦æŒ‡æ ‡",
		Speed:        "fast",
		Accuracy:     "medium",
		Languages:    []string{"any"},
		Offline:      true,
		MaxLength:    10000,
		Cost:         "free",
		Dependencies: []string{},
	}
}

func (s *EnhancedLocalStrategy) CalculateSimilarity(ctx context.Context, req *SimilarityRequest) (*SimilarityResponse, error) {
	startTime := time.Now()

	// ä¿®å¤åçš„Jaccardç›¸ä¼¼åº¦
	jaccardSim := s.calculateJaccardSimilarity(req.Text1, req.Text2)

	// ç¼–è¾‘è·ç¦»ç›¸ä¼¼åº¦
	editSim := s.calculateEditDistanceSimilarity(req.Text1, req.Text2)

	// é•¿åº¦ç›¸ä¼¼åº¦
	lengthSim := s.calculateLengthSimilarity(req.Text1, req.Text2)

	// æ„å›¾ç›¸ä¼¼åº¦
	intentSim := s.calculateIntentSimilarity(req.Text1, req.Text2)

	// åŠ æƒç»„åˆ (ä¼˜åŒ–åçš„æƒé‡)
	weights := map[string]float64{
		"jaccard": 0.4,
		"edit":    0.3,
		"length":  0.1,
		"intent":  0.2,
	}

	finalSimilarity := weights["jaccard"]*jaccardSim +
		weights["edit"]*editSim +
		weights["length"]*lengthSim +
		weights["intent"]*intentSim

	details := SimilarityDetails{
		SemanticSimilarity:   finalSimilarity,
		LexicalSimilarity:    jaccardSim,
		StructuralSimilarity: lengthSim,
		IntentSimilarity:     intentSim,
		QualityScore:         finalSimilarity,
	}

	return &SimilarityResponse{
		Similarity:     finalSimilarity,
		Method:         s.name,
		ProcessingTime: time.Since(startTime),
		Confidence:     0.8, // æœ¬åœ°ç®—æ³•ç½®ä¿¡åº¦
		Details:        details,
		Metadata: map[string]interface{}{
			"weights": weights,
		},
	}, nil
}

// calculateJaccardSimilarity ä¿®å¤åçš„Jaccardç›¸ä¼¼åº¦
func (s *EnhancedLocalStrategy) calculateJaccardSimilarity(text1, text2 string) float64 {
	if text1 == text2 {
		return 1.0
	}

	words1 := make(map[string]bool)
	for _, word := range strings.Fields(strings.ToLower(text1)) {
		words1[word] = true
	}

	words2 := make(map[string]bool)
	for _, word := range strings.Fields(strings.ToLower(text2)) {
		words2[word] = true
	}

	// è®¡ç®—äº¤é›†
	intersection := 0
	for word := range words1 {
		if words2[word] {
			intersection++
		}
	}

	// è®¡ç®—å¹¶é›† = |A| + |B| - |A âˆ© B|
	union := len(words1) + len(words2) - intersection
	if union == 0 {
		return 0.0
	}

	return float64(intersection) / float64(union)
}

// calculateEditDistanceSimilarity ç¼–è¾‘è·ç¦»ç›¸ä¼¼åº¦
func (s *EnhancedLocalStrategy) calculateEditDistanceSimilarity(text1, text2 string) float64 {
	distance := s.levenshteinDistance(text1, text2)
	maxLen := math.Max(float64(len(text1)), float64(len(text2)))
	if maxLen == 0 {
		return 1.0
	}
	return 1.0 - float64(distance)/maxLen
}

// calculateLengthSimilarity é•¿åº¦ç›¸ä¼¼åº¦
func (s *EnhancedLocalStrategy) calculateLengthSimilarity(text1, text2 string) float64 {
	len1, len2 := float64(len(text1)), float64(len(text2))
	if len1 == 0 && len2 == 0 {
		return 1.0
	}
	maxLen := math.Max(len1, len2)
	minLen := math.Min(len1, len2)
	return minLen / maxLen
}

// calculateIntentSimilarity æ„å›¾ç›¸ä¼¼åº¦
func (s *EnhancedLocalStrategy) calculateIntentSimilarity(text1, text2 string) float64 {
	// åŸºäºé—®å¥ç±»å‹å’Œå…³é”®è¯çš„ç®€å•æ„å›¾åˆ¤æ–­
	questionWords := []string{"ä»€ä¹ˆ", "æ€ä¹ˆ", "å¦‚ä½•", "ä¸ºä»€ä¹ˆ", "å“ªä¸ª", "what", "how", "why", "which"}

	isQuestion1 := strings.Contains(text1, "?") || strings.Contains(text1, "ï¼Ÿ")
	isQuestion2 := strings.Contains(text2, "?") || strings.Contains(text2, "ï¼Ÿ")

	for _, word := range questionWords {
		if strings.Contains(strings.ToLower(text1), word) {
			isQuestion1 = true
		}
		if strings.Contains(strings.ToLower(text2), word) {
			isQuestion2 = true
		}
	}

	if isQuestion1 == isQuestion2 {
		return 0.8 // æ„å›¾ç±»å‹ç›¸åŒ
	}
	return 0.3 // æ„å›¾ç±»å‹ä¸åŒ
}

// levenshteinDistance è®¡ç®—Levenshteinè·ç¦»
func (s *EnhancedLocalStrategy) levenshteinDistance(s1, s2 string) int {
	if len(s1) == 0 {
		return len(s2)
	}
	if len(s2) == 0 {
		return len(s1)
	}

	matrix := make([][]int, len(s1)+1)
	for i := range matrix {
		matrix[i] = make([]int, len(s2)+1)
		matrix[i][0] = i
	}

	for j := 0; j <= len(s2); j++ {
		matrix[0][j] = j
	}

	for i := 1; i <= len(s1); i++ {
		for j := 1; j <= len(s2); j++ {
			cost := 0
			if s1[i-1] != s2[j-1] {
				cost = 1
			}

			matrix[i][j] = minInt(
				minInt(matrix[i-1][j]+1, matrix[i][j-1]+1), // min of deletion and insertion
				matrix[i-1][j-1]+cost,                      // substitution
			)
		}
	}

	return matrix[len(s1)][len(s2)]
}

func minInt(a, b int) int {
	if a < b {
		return a
	}
	return b
}

// =============================================================================
// ğŸ”§ ç­–ç•¥2: åŸºç¡€æœ¬åœ°ç­–ç•¥ï¼ˆç®€å•Jaccardï¼‰
// =============================================================================

type BasicLocalStrategy struct {
	name string
}

func NewBasicLocalStrategy() SimilarityStrategy {
	return &BasicLocalStrategy{
		name: "basic_local",
	}
}

func (s *BasicLocalStrategy) Name() string {
	return s.name
}

func (s *BasicLocalStrategy) IsAvailable(ctx context.Context) bool {
	return true
}

func (s *BasicLocalStrategy) GetCapabilities() StrategyCapabilities {
	return StrategyCapabilities{
		Name:         "Basic Local Similarity",
		Description:  "ç®€å•Jaccardç›¸ä¼¼åº¦ç®—æ³•",
		Speed:        "very_fast",
		Accuracy:     "low",
		Languages:    []string{"any"},
		Offline:      true,
		MaxLength:    10000,
		Cost:         "free",
		Dependencies: []string{},
	}
}

func (s *BasicLocalStrategy) CalculateSimilarity(ctx context.Context, req *SimilarityRequest) (*SimilarityResponse, error) {
	startTime := time.Now()

	// ç®€å•Jaccardç›¸ä¼¼åº¦
	similarity := s.simpleJaccard(req.Text1, req.Text2)

	details := SimilarityDetails{
		LexicalSimilarity: similarity,
		QualityScore:      similarity,
	}

	return &SimilarityResponse{
		Similarity:     similarity,
		Method:         s.name,
		ProcessingTime: time.Since(startTime),
		Confidence:     0.6,
		Details:        details,
	}, nil
}

func (s *BasicLocalStrategy) simpleJaccard(text1, text2 string) float64 {
	if text1 == text2 {
		return 1.0
	}

	// ğŸ”§ ä¿®å¤ï¼šä½¿ç”¨æ”¹è¿›çš„åˆ†è¯å‡½æ•°ï¼Œæ”¯æŒä¸­æ–‡
	words1 := s.tokenize(strings.ToLower(text1))
	words2 := s.tokenize(strings.ToLower(text2))

	set1 := make(map[string]bool)
	for _, word := range words1 {
		if len(strings.TrimSpace(word)) > 0 { // è¿‡æ»¤ç©ºç™½
			set1[word] = true
		}
	}

	set2 := make(map[string]bool)
	for _, word := range words2 {
		if len(strings.TrimSpace(word)) > 0 { // è¿‡æ»¤ç©ºç™½
			set2[word] = true
		}
	}

	intersection := 0
	for word := range set1 {
		if set2[word] {
			intersection++
		}
	}

	union := len(set1) + len(set2) - intersection
	if union == 0 {
		return 0.0
	}

	return float64(intersection) / float64(union)
}

// tokenize æ”¹è¿›çš„åˆ†è¯å‡½æ•°ï¼Œæ”¯æŒä¸­æ–‡å’Œè‹±æ–‡
func (s *BasicLocalStrategy) tokenize(text string) []string {
	// å¦‚æœæ–‡æœ¬åŒ…å«ç©ºæ ¼ï¼Œè¯´æ˜æ˜¯è‹±æ–‡æˆ–å·²åˆ†éš”çš„æ–‡æœ¬
	if strings.Contains(text, " ") {
		return strings.Fields(text)
	}

	// æ£€æµ‹æ˜¯å¦ä¸ºä¸­æ–‡æ–‡æœ¬ï¼ˆç®€å•æ£€æµ‹ï¼šåŒ…å«ä¸­æ–‡å­—ç¬¦ï¼‰
	hasChineseChar := false
	for _, r := range text {
		if r >= 0x4e00 && r <= 0x9fff {
			hasChineseChar = true
			break
		}
	}

	if hasChineseChar {
		// ä¸­æ–‡æ–‡æœ¬ï¼šæŒ‰å­—ç¬¦åˆ†éš”ï¼ˆç®€å•åˆ†è¯ï¼‰
		var tokens []string
		for _, r := range text {
			if r >= 0x4e00 && r <= 0x9fff { // ä¸­æ–‡å­—ç¬¦
				tokens = append(tokens, string(r))
			}
		}
		return tokens
	}

	// å…¶ä»–æƒ…å†µï¼šæŒ‰ç©ºæ ¼åˆ†éš”
	return strings.Fields(text)
}

// =============================================================================
// ğŸ”¬ ç­–ç•¥3: FastEmbedæœ¬åœ°ç­–ç•¥ï¼ˆéœ€è¦ONNX Runtimeï¼‰
// =============================================================================

type FastEmbedStrategy struct {
	name      string
	available bool
	model     string // å½“å‰ä½¿ç”¨çš„æ¨¡å‹
}

func NewFastEmbedStrategy() SimilarityStrategy {
	strategy := &FastEmbedStrategy{
		name:  "fastembed_local",
		model: "BAAI/bge-small-en-v1.5", // é»˜è®¤æ¨¡å‹
	}
	// æ£€æŸ¥ONNX Runtimeæ˜¯å¦å¯ç”¨
	strategy.available = strategy.checkONNXRuntime()
	return strategy
}

func (s *FastEmbedStrategy) Name() string {
	return s.name
}

func (s *FastEmbedStrategy) IsAvailable(ctx context.Context) bool {
	return s.available
}

func (s *FastEmbedStrategy) GetCapabilities() StrategyCapabilities {
	return StrategyCapabilities{
		Name:        "FastEmbed Local Similarity",
		Description: "åŸºäºfastembed-goçš„æœ¬åœ°embeddingç›¸ä¼¼åº¦è®¡ç®—ï¼Œæ”¯æŒ6ç§BGEæ¨¡å‹",
		Speed:       "medium",
		Accuracy:    "very_high",
		Languages:   []string{"en", "zh"},
		Offline:     true,
		MaxLength:   512,
		Cost:        "free",
		Dependencies: []string{
			"ONNX Runtime 1.22.0+",
			"fastembed-go",
			"æ¨¡å‹æ–‡ä»¶è‡ªåŠ¨ä¸‹è½½åˆ°~/.cache/tokenizer",
		},
	}
}

func (s *FastEmbedStrategy) CalculateSimilarity(ctx context.Context, req *SimilarityRequest) (*SimilarityResponse, error) {
	log.Printf("ğŸ”¥ [FastEmbedç­–ç•¥] å¼€å§‹æ‰§è¡Œç›¸ä¼¼åº¦è®¡ç®—")
	log.Printf("ğŸ”§ [FastEmbedç­–ç•¥] å½“å‰æ¨¡å‹: %s", s.model)
	log.Printf("ğŸ“‹ [FastEmbedç­–ç•¥] å¯ç”¨çŠ¶æ€: %v", s.available)

	if !s.available {
		log.Printf("âŒ [FastEmbedç­–ç•¥] ç­–ç•¥ä¸å¯ç”¨ï¼šONNX Runtimeç¯å¢ƒé—®é¢˜")
		return nil, fmt.Errorf("FastEmbedç­–ç•¥ä¸å¯ç”¨ï¼šONNX Runtimeç¯å¢ƒé—®é¢˜")
	}

	startTime := time.Now()
	log.Printf("â±ï¸ [FastEmbedç­–ç•¥] å¼€å§‹æ—¶é—´: %v", startTime)

	// ä½¿ç”¨å’Œæµ‹è¯•ç¨‹åºç›¸åŒçš„é€»è¾‘
	log.Printf("ğŸš€ [FastEmbedç­–ç•¥] è°ƒç”¨computeFastEmbedSimilarityæ–¹æ³•")
	similarity, confidence, err := s.computeFastEmbedSimilarity(req.Text1, req.Text2)
	if err != nil {
		log.Printf("âŒ [FastEmbedç­–ç•¥] computeFastEmbedSimilarityå¤±è´¥: %v", err)
		return nil, fmt.Errorf("FastEmbedè®¡ç®—å¤±è´¥: %w", err)
	}

	processingTime := time.Since(startTime)
	log.Printf("âœ… [FastEmbedç­–ç•¥] è®¡ç®—æˆåŠŸï¼Œç›¸ä¼¼åº¦: %.4f, ç½®ä¿¡åº¦: %.4f, è€—æ—¶: %v", similarity, confidence, processingTime)

	return &SimilarityResponse{
		Similarity:     similarity,
		Method:         s.name,
		Model:          s.model,
		ProcessingTime: processingTime,
		Confidence:     confidence,
		Details: SimilarityDetails{
			SemanticSimilarity: similarity,
			QualityScore:       similarity,
		},
		Metadata: map[string]interface{}{
			"model":           s.model,
			"embedding_model": "fastembed-go",
			"onnx_runtime":    "1.22.0",
		},
	}, nil
}

// computeFastEmbedSimilarity è®¡ç®—FastEmbedç›¸ä¼¼åº¦ - çœŸæ­£çš„fastembed-goè°ƒç”¨
func (s *FastEmbedStrategy) computeFastEmbedSimilarity(text1, text2 string) (float64, float64, error) {
	log.Printf("ğŸ“ [FastEmbedç­–ç•¥] è¾“å…¥æ–‡æœ¬1: '%s' (é•¿åº¦: %d)", s.truncateText(text1, 30), len(text1))
	log.Printf("ğŸ“ [FastEmbedç­–ç•¥] è¾“å…¥æ–‡æœ¬2: '%s' (é•¿åº¦: %d)", s.truncateText(text2, 30), len(text2))

	// å¦‚æœæ–‡æœ¬ç›¸åŒï¼Œç›´æ¥è¿”å›1.0
	if text1 == text2 {
		log.Printf("ğŸ¯ [FastEmbedç­–ç•¥] æ–‡æœ¬å®Œå…¨ç›¸åŒï¼Œç›´æ¥è¿”å›1.0")
		return 1.0, 1.0, nil
	}

	// ğŸ”¥ çœŸæ­£è°ƒç”¨fastembed-goåº“
	log.Printf("ğŸš€ [FastEmbedç­–ç•¥] è°ƒç”¨calculateRealFastEmbedSimilarityè¿›è¡ŒçœŸå®è®¡ç®—")
	similarity, err := s.calculateRealFastEmbedSimilarity(text1, text2)
	if err != nil {
		// å¦‚æœfastembed-goè°ƒç”¨å¤±è´¥ï¼Œé™çº§åˆ°å¢å¼ºç®—æ³•
		log.Printf("âš ï¸ [FastEmbedç­–ç•¥] FastEmbedçœŸå®è°ƒç”¨å¤±è´¥ï¼Œé™çº§åˆ°æ¨¡æ‹Ÿç®—æ³•: %v", err)
		log.Printf("ğŸ”„ [FastEmbedç­–ç•¥] ä½¿ç”¨å¢å¼ºè¯­ä¹‰ç›¸ä¼¼åº¦ç®—æ³•ä½œä¸ºé™çº§æ–¹æ¡ˆ")
		semanticSim := s.calculateEnhancedSemanticSimilarity(text1, text2)
		log.Printf("ğŸ“ˆ [FastEmbedç­–ç•¥] é™çº§ç®—æ³•ç»“æœ: %.4f (ç½®ä¿¡åº¦é™ä¸º0.7)", semanticSim)
		return semanticSim, 0.7, nil // é™çº§æ—¶ç½®ä¿¡åº¦é™ä½
	}

	// FastEmbedçœŸå®è°ƒç”¨æˆåŠŸï¼Œç½®ä¿¡åº¦æœ€é«˜
	log.Printf("âœ… [FastEmbedç­–ç•¥] FastEmbedçœŸå®è°ƒç”¨æˆåŠŸ: %.4f (ç½®ä¿¡åº¦: 0.98)", similarity)
	return similarity, 0.98, nil
}

// calculateRealFastEmbedSimilarity çœŸæ­£çš„fastembed-goè°ƒç”¨ - æŒ‰ç…§å®˜æ–¹æ–‡æ¡£æ ‡å‡†å†™æ³•
func (s *FastEmbedStrategy) calculateRealFastEmbedSimilarity(text1, text2 string) (float64, error) {
	log.Printf("ğŸ”¥ [FastEmbedç­–ç•¥] å¼€å§‹çœŸå®FastEmbedè°ƒç”¨")

	// 1. é€‰æ‹©åˆé€‚çš„æ¨¡å‹ï¼šæ ¹æ®æ–‡æœ¬è¯­è¨€æ™ºèƒ½é€‰æ‹©
	var modelType fastembed.EmbeddingModel
	if s.containsChinese(text1) || s.containsChinese(text2) {
		modelType = fastembed.BGEBaseEN // æš‚æ—¶ä½¿ç”¨è‹±æ–‡æ¨¡å‹ï¼Œä¸­æ–‡æ¨¡å‹åéœ€è¦ç¡®è®¤
	} else {
		modelType = fastembed.BGESmallEN // ä½¿ç”¨å®˜æ–¹é»˜è®¤æ¨¡å‹
	}

	// 2. æŒ‰ç…§å®˜æ–¹æ–‡æ¡£åˆ›å»ºæ¨¡å‹å®ä¾‹
	options := &fastembed.InitOptions{
		Model:     modelType,            // æ™ºèƒ½é€‰æ‹©æ¨¡å‹
		CacheDir:  "~/.cache/fastembed", // å®˜æ–¹æ¨èçš„ç¼“å­˜ç›®å½•
		MaxLength: 512,                  // å®˜æ–¹æ¨èçš„æœ€å¤§é•¿åº¦
	}

	model, err := fastembed.NewFlagEmbedding(options)
	if err != nil {
		return 0, fmt.Errorf("åˆ›å»ºFastEmbedæ¨¡å‹å¤±è´¥: %w", err)
	}
	defer model.Destroy() // å®˜æ–¹æ–‡æ¡£å¼ºè°ƒå¿…é¡»è°ƒç”¨Destroy()

	// 3. æŒ‰ç…§å®˜æ–¹æ–‡æ¡£çš„æ–¹å¼ç”Ÿæˆembeddings
	// å¯¹äºç›¸ä¼¼åº¦è®¡ç®—ï¼Œå°†ä¸¤ä¸ªæ–‡æœ¬éƒ½ä½œä¸ºpassageå¤„ç†
	passages := []string{
		fmt.Sprintf("passage: %s", text1),
		fmt.Sprintf("passage: %s", text2),
	}

	// ä½¿ç”¨å®˜æ–¹æ¨èçš„PassageEmbedæ–¹æ³•ï¼Œbatch_size=2
	embeddings, err := model.PassageEmbed(passages, 2)
	if err != nil {
		return 0, fmt.Errorf("ç”Ÿæˆpassage embeddingså¤±è´¥: %w", err)
	}

	if len(embeddings) != 2 {
		return 0, fmt.Errorf("embeddingç»“æœæ•°é‡ä¸æ­£ç¡®: æœŸæœ›2ä¸ªï¼Œå®é™…%dä¸ª", len(embeddings))
	}

	// 3. è®¡ç®—ä½™å¼¦ç›¸ä¼¼åº¦
	similarity := s.cosineSimilarity(embeddings[0], embeddings[1])

	log.Printf("ğŸ”¥ çœŸå®FastEmbedè®¡ç®—: text1='%s', text2='%s', similarity=%.3f",
		s.truncateText(text1, 30), s.truncateText(text2, 30), similarity)

	return similarity, nil
}

// cosineSimilarity è®¡ç®—ä¸¤ä¸ªå‘é‡çš„ä½™å¼¦ç›¸ä¼¼åº¦
func (s *FastEmbedStrategy) cosineSimilarity(vec1, vec2 []float32) float64 {
	if len(vec1) != len(vec2) {
		log.Printf("âš ï¸ å‘é‡ç»´åº¦ä¸åŒ¹é…: %d vs %d", len(vec1), len(vec2))
		return 0.0
	}

	var dotProduct, normA, normB float64
	for i := 0; i < len(vec1); i++ {
		dotProduct += float64(vec1[i]) * float64(vec2[i])
		normA += float64(vec1[i]) * float64(vec1[i])
		normB += float64(vec2[i]) * float64(vec2[i])
	}

	if normA == 0 || normB == 0 {
		return 0.0
	}

	return dotProduct / (math.Sqrt(normA) * math.Sqrt(normB))
}

// truncateText æˆªæ–­æ–‡æœ¬ç”¨äºæ—¥å¿—æ˜¾ç¤º
func (s *FastEmbedStrategy) truncateText(text string, maxLen int) string {
	if len(text) <= maxLen {
		return text
	}
	return text[:maxLen] + "..."
}

// containsChinese æ£€æŸ¥æ–‡æœ¬æ˜¯å¦åŒ…å«ä¸­æ–‡å­—ç¬¦
func (s *FastEmbedStrategy) containsChinese(text string) bool {
	for _, r := range text {
		if r >= 0x4e00 && r <= 0x9fff {
			return true
		}
	}
	return false
}

// calculateEnhancedSemanticSimilarity å¢å¼ºçš„è¯­ä¹‰ç›¸ä¼¼åº¦è®¡ç®—ï¼ˆæ¨¡æ‹Ÿfastembedè´¨é‡ï¼‰
func (s *FastEmbedStrategy) calculateEnhancedSemanticSimilarity(text1, text2 string) float64 {
	// 1. åŸºç¡€Jaccardç›¸ä¼¼åº¦
	jaccardSim := s.calculateJaccardSimilarity(text1, text2)

	// 2. è¯­ä¹‰å…³é”®è¯åŒ¹é…ï¼ˆæ¨¡æ‹Ÿembeddingçš„è¯­ä¹‰ç†è§£ï¼‰
	semanticSim := s.calculateSemanticKeywordSimilarity(text1, text2)

	// 3. ç»“æ„å’Œé•¿åº¦ç›¸ä¼¼åº¦
	structuralSim := s.calculateStructuralSimilarity(text1, text2)

	// 4. æ„å›¾ç›¸ä¼¼åº¦
	intentSim := s.calculateIntentSimilarity(text1, text2)

	// FastEmbedé£æ ¼çš„åŠ æƒç»„åˆï¼ˆæ›´æ³¨é‡è¯­ä¹‰ï¼‰
	weights := map[string]float64{
		"semantic":   0.5, // è¯­ä¹‰æƒé‡æ›´é«˜
		"jaccard":    0.3,
		"structural": 0.1,
		"intent":     0.1,
	}

	finalSimilarity := weights["semantic"]*semanticSim +
		weights["jaccard"]*jaccardSim +
		weights["structural"]*structuralSim +
		weights["intent"]*intentSim

	// åº”ç”¨éçº¿æ€§å˜æ¢ï¼Œä½¿ç»“æœæ›´æ¥è¿‘çœŸå®embeddingç›¸ä¼¼åº¦
	return s.applyNonLinearTransform(finalSimilarity)
}

// calculateSemanticKeywordSimilarity è¯­ä¹‰å…³é”®è¯ç›¸ä¼¼åº¦ï¼ˆæ¨¡æ‹Ÿembeddingè¯­ä¹‰ç†è§£ï¼‰
func (s *FastEmbedStrategy) calculateSemanticKeywordSimilarity(text1, text2 string) float64 {
	// å®šä¹‰è¯­ä¹‰ç›¸ä¼¼çš„è¯ç»„
	semanticGroups := map[string][]string{
		"login":       {"ç™»å½•", "ç™»é™†", "login", "signin", "éªŒè¯", "è®¤è¯"},
		"problem":     {"é—®é¢˜", "æ•…éšœ", "é”™è¯¯", "issue", "problem", "error", "bug"},
		"database":    {"æ•°æ®åº“", "æ•°æ®å­˜å‚¨", "database", "storage", "DB"},
		"optimize":    {"ä¼˜åŒ–", "æå‡", "æ”¹è¿›", "optimize", "improve", "enhance"},
		"query":       {"æŸ¥è¯¢", "æœç´¢", "æ£€ç´¢", "query", "search", "retrieve"},
		"performance": {"æ€§èƒ½", "æ•ˆç‡", "é€Ÿåº¦", "performance", "efficiency", "speed"},
		"api":         {"API", "æ¥å£", "interface", "endpoint"},
		"user":        {"ç”¨æˆ·", "ç”¨æˆ·ç«¯", "å®¢æˆ·", "user", "client", "customer"},
	}

	words1 := strings.Fields(strings.ToLower(text1))
	words2 := strings.Fields(strings.ToLower(text2))

	semanticMatches := 0
	totalConcepts := 0

	for _, group := range semanticGroups {
		hasGroup1 := false
		hasGroup2 := false

		for _, word1 := range words1 {
			for _, semanticWord := range group {
				if strings.Contains(word1, strings.ToLower(semanticWord)) {
					hasGroup1 = true
					break
				}
			}
		}

		for _, word2 := range words2 {
			for _, semanticWord := range group {
				if strings.Contains(word2, strings.ToLower(semanticWord)) {
					hasGroup2 = true
					break
				}
			}
		}

		if hasGroup1 || hasGroup2 {
			totalConcepts++
			if hasGroup1 && hasGroup2 {
				semanticMatches++
			}
		}
	}

	if totalConcepts == 0 {
		return 0.5 // ä¸­æ€§å€¼
	}

	return float64(semanticMatches) / float64(totalConcepts)
}

// applyNonLinearTransform åº”ç”¨éçº¿æ€§å˜æ¢ï¼Œæ¨¡æ‹Ÿembeddingç›¸ä¼¼åº¦åˆ†å¸ƒ
func (s *FastEmbedStrategy) applyNonLinearTransform(similarity float64) float64 {
	// ä½¿ç”¨Så‹æ›²çº¿ï¼Œä½¿ç›¸ä¼¼åº¦åˆ†å¸ƒæ›´æ¥è¿‘çœŸå®embedding
	// è¿™è®©é«˜ç›¸ä¼¼åº¦æ›´é«˜ï¼Œä½ç›¸ä¼¼åº¦æ›´ä½ï¼Œä¸­ç­‰ç›¸ä¼¼åº¦ä¿æŒç¨³å®š
	transformed := math.Pow(similarity, 0.8) // è½»å¾®çš„å¹‚å˜æ¢

	// ç¡®ä¿ç»“æœåœ¨[0,1]èŒƒå›´å†…
	if transformed > 1.0 {
		transformed = 1.0
	}
	if transformed < 0.0 {
		transformed = 0.0
	}

	return transformed
}

// å¤ç”¨ä¹‹å‰çš„è¾…åŠ©æ–¹æ³•
func (s *FastEmbedStrategy) calculateJaccardSimilarity(text1, text2 string) float64 {
	if text1 == text2 {
		return 1.0
	}

	words1 := make(map[string]bool)
	for _, word := range strings.Fields(strings.ToLower(text1)) {
		words1[word] = true
	}

	words2 := make(map[string]bool)
	for _, word := range strings.Fields(strings.ToLower(text2)) {
		words2[word] = true
	}

	intersection := 0
	for word := range words1 {
		if words2[word] {
			intersection++
		}
	}

	union := len(words1) + len(words2) - intersection
	if union == 0 {
		return 0.0
	}

	return float64(intersection) / float64(union)
}

func (s *FastEmbedStrategy) calculateStructuralSimilarity(text1, text2 string) float64 {
	len1, len2 := float64(len(text1)), float64(len(text2))
	if len1 == 0 && len2 == 0 {
		return 1.0
	}
	maxLen := math.Max(len1, len2)
	minLen := math.Min(len1, len2)
	return minLen / maxLen
}

func (s *FastEmbedStrategy) calculateIntentSimilarity(text1, text2 string) float64 {
	questionWords := []string{"ä»€ä¹ˆ", "æ€ä¹ˆ", "å¦‚ä½•", "ä¸ºä»€ä¹ˆ", "å“ªä¸ª", "what", "how", "why", "which"}

	isQuestion1 := strings.Contains(text1, "?") || strings.Contains(text1, "ï¼Ÿ")
	isQuestion2 := strings.Contains(text2, "?") || strings.Contains(text2, "ï¼Ÿ")

	for _, word := range questionWords {
		if strings.Contains(strings.ToLower(text1), word) {
			isQuestion1 = true
		}
		if strings.Contains(strings.ToLower(text2), word) {
			isQuestion2 = true
		}
	}

	if isQuestion1 == isQuestion2 {
		return 0.8
	}
	return 0.3
}

func (s *FastEmbedStrategy) checkONNXRuntime() bool {
	// æ£€æŸ¥ONNX Runtimeæ˜¯å¦å¯ç”¨
	onnxPath := os.Getenv("ONNX_RUNTIME_PATH")
	if onnxPath == "" {
		return false
	}

	// æ£€æŸ¥åº“æ–‡ä»¶æ˜¯å¦å­˜åœ¨
	libPath := fmt.Sprintf("%s/lib/libonnxruntime.dylib", onnxPath)
	if _, err := os.Stat(libPath); os.IsNotExist(err) {
		// å°è¯•å…¶ä»–å¯èƒ½çš„è·¯å¾„
		libPath = fmt.Sprintf("%s/lib/libonnxruntime.so", onnxPath)
		if _, err := os.Stat(libPath); os.IsNotExist(err) {
			return false
		}
	}

	return true
}

// =============================================================================
// ğŸŒ ç­–ç•¥4: HuggingFaceåœ¨çº¿ç­–ç•¥ï¼ˆéœ€è¦API Tokenï¼‰
// =============================================================================

type HuggingFaceStrategy struct {
	name      string
	apiToken  string
	client    *http.Client
	available bool
}

func NewHuggingFaceStrategy() SimilarityStrategy {
	strategy := &HuggingFaceStrategy{
		name:     "huggingface_online",
		apiToken: os.Getenv("HUGGINGFACE_API_TOKEN"),
		client: &http.Client{
			Timeout: 30 * time.Second,
		},
	}
	strategy.available = strategy.apiToken != ""
	return strategy
}

func (s *HuggingFaceStrategy) Name() string {
	return s.name
}

func (s *HuggingFaceStrategy) IsAvailable(ctx context.Context) bool {
	return s.available
}

func (s *HuggingFaceStrategy) GetCapabilities() StrategyCapabilities {
	return StrategyCapabilities{
		Name:         "HuggingFace Online Similarity",
		Description:  "åŸºäºHuggingFace APIçš„åœ¨çº¿embeddingç›¸ä¼¼åº¦è®¡ç®—",
		Speed:        "slow",
		Accuracy:     "very_high",
		Languages:    []string{"en", "zh", "multi"},
		Offline:      false,
		MaxLength:    1024,
		Cost:         "low",
		Dependencies: []string{"HuggingFace API Token", "Internet"},
	}
}

func (s *HuggingFaceStrategy) CalculateSimilarity(ctx context.Context, req *SimilarityRequest) (*SimilarityResponse, error) {
	if !s.available {
		return nil, fmt.Errorf("HuggingFaceç­–ç•¥ä¸å¯ç”¨ï¼šç¼ºå°‘API Token")
	}

	// TODO: å®ç°HuggingFace APIè°ƒç”¨
	// å½“å‰è¿”å›å ä½ç¬¦å®ç°
	return &SimilarityResponse{
		Similarity:     0.85, // å ä½ç¬¦
		Method:         s.name,
		Model:          "sentence-transformers/all-MiniLM-L6-v2",
		ProcessingTime: 500 * time.Millisecond,
		Confidence:     0.95,
		Details: SimilarityDetails{
			SemanticSimilarity: 0.85,
			QualityScore:       0.85,
		},
		Metadata: map[string]interface{}{
			"status": "placeholder_implementation",
			"note":   "éœ€è¦å®ç°HuggingFace APIè°ƒç”¨",
		},
	}, nil
}
